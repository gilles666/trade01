<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Chart + Moyennes Mobiles (SMA/EMA) — GitHub Pages</title>
  <!-- Lightweight Charts (par TradingView) - Open source, parfait pour GitHub Pages -->
  <script>
  // Charge Lightweight Charts avec fallback (unpkg -> jsDelivr)
  (function loadLWC(d){
    function inject(src, next){
      var s=d.createElement('script'); s.src=src; s.async=false;
      s.onload=function(){ console.log('Loaded', src); };
      s.onerror=function(){ console.warn('Failed', src); next && next(); };
      d.head.appendChild(s);
    }
    inject('https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js', function(){
      inject('https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js');
    });
  })(document);
</script>
  <style>
    :root { --bg:#0b1020; --fg:#e6e7ea; --muted:#9aa1b1; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    h1 { font-size: 20px; margin: 0; }
    .card { background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.06); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); padding: 12px; }
    #chart { height: 60vh; min-height: 360px; }
    .legend { display:flex; gap: 16px; font-size: 12px; color: var(--muted); padding: 6px 8px; }
    .pill { padding: 4px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); }
    .row { display:flex; gap: 12px; align-items:center; flex-wrap: wrap; }
    button, select, input { background: rgba(255,255,255,0.06); color: var(--fg); border:1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 8px 10px; }
    button { cursor: pointer; }
    a { color:#9ecbff; }
    footer { margin-top: 16px; font-size: 12px; color: var(--muted); }
    .hint { font-size:12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Graphique live + SMA/EMA (Lightweight Charts)v4</h1>
      <div class="row">
        <label>
          Source de données :
          <select id="dataSource">
            <option value="simulated">Simulation (démo)</option>
            <option value="binance">Binance (trades → bougies 1s)</option>
            <option value="ws">WebSocket personnalisé</option>
          </select>
        </label>
        <label>
          Symbole (Binance):
          <input id="symbol" value="btcusdt" size="10" />
        </label>
        <label>
          WS perso:
          <input id="customWsUrl" placeholder="wss://example.com/your-stream" size="28" />
        </label>
        <button id="reset">Démarrer / Réinitialiser</button>
      </div>
      <div class="hint">Binance: utilise le flux <code>@trade</code> et agrège en bougies d'1 seconde côté client. WS perso: envoyez des JSON {time, open, high, low, close} (time en secondes).</div>
    </header>

    <div class="card">
      <div id="chart"></div>
      <div class="legend" id="legend">
        <span class="pill">Bougie OHLC</span>
        <span class="pill" id="smaLabel">SMA(20): —</span>
        <span class="pill" id="emaLabel">EMA(50): —</span>
        <span class="pill" id="priceLabel">Dernier: —</span>
        <span class="pill" id="status">Statut: init…</span>
      </div>
    </div>

    <footer>
      <p>
        Ce composant utilise <a href="https://github.com/tradingview/lightweight-charts" target="_blank" rel="noreferrer">Lightweight Charts</a> (par TradingView), idéal pour une intégration 100% front-end sur GitHub Pages.
        Si vous avez besoin du <em>Charting Library</em> complet de TradingView (avec dessin, indicateurs intégrés avancés, multi-charts, etc.), vous devez demander une licence et mettre en place un <em>datafeed</em> UDF. Voir la note dans le code.
      </p>
    </footer>
  </div>

  <script>
    // === 1) Créer le graphique ===
    const container = document.getElementById('chart');
    const statusEl = document.getElementById('status');
    function setStatus(txt){ if(statusEl) statusEl.textContent = 'Statut: '+txt; }

    // === Ajout: initialisation paresseuse du chart quand la librairie est prête ===
    let chart = null, candleSeries = null, smaSeries = null, emaSeries = null;
    function ensureChart(){
      if (chart) return true;
      if (!window.LightweightCharts) return false;
      try {
        chart = LightweightCharts.createChart(container, {
          layout: { background: { color: getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() }, textColor: getComputedStyle(document.documentElement).getPropertyValue('--fg').trim() },
          grid: { vertLines: { color: 'rgba(255,255,255,0.06)'}, horzLines: { color: 'rgba(255,255,255,0.06)'} },
          timeScale: { timeVisible: true, secondsVisible: true, borderColor: 'rgba(255,255,255,0.12)' },
          rightPriceScale: { borderColor: 'rgba(255,255,255,0.12)' },
          crosshair: { mode: LightweightCharts.CrosshairMode.Magnet },
          autoSize: true,
        });
        candleSeries = chart.addCandlestickSeries();
        smaSeries = chart.addLineSeries({ lineWidth: 2 });
        emaSeries = chart.addLineSeries({ lineWidth: 2 });
        setStatus('lib chargée, graphique prêt');
        return true;
      } catch(e){ console.error(e); setStatus('erreur init chart: '+(e.message||e)); return false; }
    }

    window.__onLWCLoaded = function(){ setStatus('lib chargée'); ensureChart(); }

    // (remplacé par ensureChart)

    const smaPeriod = 20;
    const emaPeriod = 50;

    // Buffers
    const candles = []; // { time, open, high, low, close }
    const smaValues = []; // { time, value }
    const emaValues = []; // { time, value }

    // Helpers SMA/EMA incrémentales
    function calcSMA(latestClose) {
      closes.push(latestClose);
      if (closes.length > smaPeriod) closes.shift();
      if (closes.length < smaPeriod) return null;
      const sum = closes.reduce((a,b)=>a+b,0);
      return sum / smaPeriod;
    }

    let emaPrev = null;
    const k = 2 / (emaPeriod + 1);
    function calcEMA(latestClose) {
      if (emaPrev === null) { // amorçage par SMA des 1ers points
        seed.push(latestClose);
        if (seed.length < emaPeriod) return null;
        emaPrev = seed.reduce((a,b)=>a+b,0) / emaPeriod;
        return emaPrev;
      }
      emaPrev = latestClose * k + emaPrev * (1 - k);
      return emaPrev;
    }

    const closes = []; // pour SMA
    const seed = [];   // pour initialiser EMA

    const smaLabel = document.getElementById('smaLabel');
    const emaLabel = document.getElementById('emaLabel');
    const priceLabel = document.getElementById('priceLabel');

    function addOrUpdateBar(bar) {
      const last = candles[candles.length-1];
      if (last && last.time === bar.time) {
        // update candle in place
        last.open = bar.open;
        last.high = Math.max(last.high, bar.high);
        last.low  = Math.min(last.low, bar.low);
        last.close = bar.close;
        candleSeries.update(last);
      } else {
        candles.push(bar);
        if(candleSeries) candleSeries.update(bar);
      }

      const sma = calcSMA(bar.close);
      const ema = calcEMA(bar.close);

      if (sma !== null) {
        const pt = { time: bar.time, value: +sma.toFixed(2) };
        if (smaValues.length && smaValues[smaValues.length-1].time === bar.time) {
          smaValues[smaValues.length-1] = pt;
          if(smaSeries) smaSeries.update(pt);
        } else {
          smaValues.push(pt); if(smaSeries) smaSeries.update(pt);
        }
        smaLabel.textContent = `SMA(${smaPeriod}): ${pt.value}`;
      }
      if (ema !== null) {
        const pt = { time: bar.time, value: +ema.toFixed(2) };
        if (emaValues.length && emaValues[emaValues.length-1].time === bar.time) {
          emaValues[emaValues.length-1] = pt;
          if(emaSeries) emaSeries.update(pt);
        } else {
          emaValues.push(pt); if(emaSeries) emaSeries.update(pt);
        }
        emaLabel.textContent = `EMA(${emaPeriod}): ${pt.value}`;
      }
      priceLabel.textContent = `Dernier: ${bar.close}`;
    }

    // === 2) Historique minimal (bougies 1s) ===
    function seedHistory(n=200) {
      const now = Math.floor(Date.now()/1000);
      let last = 50000; // prix de base fictif
      const tmpCloses = [];
      const tmpSeed = [];
      for (let i=n; i>0; i--) {
        const t = now - i;
        const vol = (Math.random()*20)+5;
        const open = last;
        const delta = (Math.random()-0.5) * vol;
        const close = +(open + delta).toFixed(2);
        const high = Math.max(open, close) + Math.random()*5;
        const low  = Math.min(open, close) - Math.random()*5;
        last = close;
        candles.push({ time: t, open, high, low, close });
      }
      if(candleSeries) candleSeries.setData(candles);

      // recalculer SMA/EMA depuis zéro
      closes.length = 0; seed.length = 0; emaPrev = null; smaValues.length = 0; emaValues.length = 0;
      candles.forEach(c => {
        const sma = calcSMA(c.close);
        const ema = calcEMA(c.close);
        if (sma !== null) smaValues.push({ time:c.time, value:+sma.toFixed(2) });
        if (ema !== null) emaValues.push({ time:c.time, value:+ema.toFixed(2) });
      });
      if (smaValues.length) if(smaSeries) smaSeries.setData(smaValues);
      if (emaValues.length) if(emaSeries) emaSeries.setData(emaValues);

      const lastC = candles[candles.length-1];
      priceLabel.textContent = `Dernier: ${lastC.close}`;
      if (smaValues.length) smaLabel.textContent = `SMA(${smaPeriod}): ${smaValues[smaValues.length-1].value}`;
      if (emaValues.length) emaLabel.textContent = `EMA(${emaPeriod}): ${emaValues[emaValues.length-1].value}`;
    }

    // === 3) Flux live ===
    let intervalId = null;
    let ws = null;

    function startSimulatedFeed() {
      stopFeeds();
      intervalId = setInterval(() => {
        const t = Math.floor(Date.now()/1000);
        const last = candles[candles.length-1] ?? { close: 50000 };
        const open = last.close;
        const vol = (Math.random()*28)+7;
        const delta = (Math.random()-0.5) * vol;
        const close = +(open + delta).toFixed(2);
        const high = Math.max(open, close) + Math.random()*6;
        const low  = Math.min(open, close) - Math.random()*6;
        addOrUpdateBar({ time: t, open, high, low, close });
      }, 1000);
    }

    function startCustomWsFeed(url) {
      stopFeeds();
      if (!url) { alert('Renseignez l\'URL du WebSocket personnalisé'); return; }
      ws = new WebSocket(url);
      ws.onopen = () => console.log('WS perso connecté');
      ws.onmessage = (evt) => {
        // Attendez un payload au format: {time, open, high, low, close}
        try {
          const msg = JSON.parse(evt.data);
          if (msg.time && msg.open!=null) addOrUpdateBar(msg);
        } catch(e) { console.warn('WS message invalide', e); }
      };
      ws.onclose = () => console.log('WS perso fermé');
      ws.onerror = (e) => console.error('WS perso erreur', e);
    }

    // Agrégation trades Binance -> bougies 1s
    let binanceBucket = null; // {sec, open, high, low, close}
    function flushBinanceBucket(force=false) {
      if (!binanceBucket) return;
      addOrUpdateBar({
        time: binanceBucket.sec,
        open: binanceBucket.open,
        high: binanceBucket.high,
        low:  binanceBucket.low,
        close:binanceBucket.close,
      });
      if (force) binanceBucket = null;
    }

    function startBinanceTrades(symbol='btcusdt') {
      stopFeeds();
      const stream = `${symbol.toLowerCase()}@trade`;
      const url = `wss://stream.binance.com:9443/ws/${stream}`;
      ws = new WebSocket(url);
      ws.onopen = () => { console.log('Binance connecté:', stream); binanceBucket = null; };
      ws.onmessage = (evt) => {
        try {
          const t = JSON.parse(evt.data);
          // structure: { e: 'trade', E: eventTime, s: 'BTCUSDT', t: tradeId, p: 'prix', q:'qty', b: buyerId, a: sellerId, T: tradeTime(ms), m: isBuyerMaker }
          const price = parseFloat(t.p);
          const sec = Math.floor(t.T / 1000);

          if (!binanceBucket || binanceBucket.sec !== sec) {
            // pousser le bucket précédent
            flushBinanceBucket(true);
            // démarrer un nouveau bucket sur cette seconde
            binanceBucket = { sec, open: price, high: price, low: price, close: price };
          } else {
            // mettre à jour le bucket courant
            binanceBucket.high = Math.max(binanceBucket.high, price);
            binanceBucket.low  = Math.min(binanceBucket.low, price);
            binanceBucket.close = price;
          }
          // Pousser une mise à jour "en cours" (sans fermer la bougie)
          addOrUpdateBar({ time: sec, open: binanceBucket.open, high: binanceBucket.high, low: binanceBucket.low, close: binanceBucket.close });
        } catch(e) {
          console.warn('Binance trade invalide', e);
        }
      };
      ws.onclose = () => { console.log('Binance fermé'); flushBinanceBucket(true); };
      ws.onerror = (e) => console.error('Binance erreur', e);
    }

    function stopFeeds() {
      if (intervalId) { clearInterval(intervalId); intervalId = null; }
      if (ws) { try { ws.close(); } catch(e){} ws = null; }
    }

    // === 4) UI ===
    function resetAll() {
      if (!ensureChart()) { setStatus('lib non chargée'); return; }
      stopFeeds();
      candles.length = 0; smaValues.length = 0; emaValues.length = 0; closes.length = 0; seed.length = 0; emaPrev = null;
      if(candleSeries) candleSeries.setData([]); if(smaSeries) smaSeries.setData([]); if(emaSeries) emaSeries.setData([]);
      seedHistory();
      const mode = document.getElementById('dataSource').value;
      const symbol = document.getElementById('symbol').value || 'btcusdt';
      const custom = document.getElementById('customWsUrl').value || '';
      if (mode === 'simulated') startSimulatedFeed();
      else if (mode === 'binance') startBinanceTrades(symbol);
      else if (mode === 'ws') startCustomWsFeed(custom);
    }

    document.getElementById('dataSource').addEventListener('change', () => {});
    document.getElementById('reset').addEventListener('click', function(){
      setStatus('initialisation…');
      try { resetAll(); setStatus('en cours'); } catch(e){ console.error(e); setStatus('erreur: '+(e.message||e)); }
    });

    // Boot par défaut: historique + simulation
    function boot(){
      if (ensureChart()) {
        try { seedHistory(); startSimulatedFeed(); setStatus('simulation active'); }
        catch(e){ console.error(e); setStatus('erreur boot: '+(e.message||e)); }
      } else {
        setStatus('en attente de la librairie…');
        setTimeout(boot, 250);
      }
    }
    boot();

    // Aide: si le graphique n'apparaît pas, vérifiez la console (F12) et la politique CSP.
  </script>
</body>
</html>
